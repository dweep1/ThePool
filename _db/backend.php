<?php

if(!session_id()) {
    @session_start();
} else {

}

//@TODO change functions to use $options array instead of long constructors
//@TODO add the ability to change sorting
//@TODO getNext should be 1 object only, getNextList should handle pagination
//@TODO add new functions getPrevious, getPreviousList
//@TODO continue commenting
//@TODO modular file structure
//@TODO update should handle more robust datasets (thinks like an array of new data)

//Cool Stuff
//@TODO menu system overhaul - a more robust menu system with children and parents
//@TODO built into framework object chaining for deleting, MYSQL JOIN, and updating of objects
//@TODO creation of tables if they do not exist, automagically.
//@TODO backing up of data automagically
//@TODO page caching system
//@TODO data display should run on angular JS instead, perhaps using HTML5 storage to save selected object, then displaying it on page
//@TODO Email system for emailing datagrams and members
//@TODO re-encode line breaks in phpbb for the web application so that they display correctly on the forums
//@TODO angularJS data sorting using a dropdown

//PERMISSIONS
//@TODO Permissions System Overhaul
//@TODO Method Permissions Level
//@TODO permissions system overhaul+addition - The ability to embed permissions in code in a web page, and specify a name and a pLevel
//@TODO more robust permissions system that allows methods to have a permission set
//@TODO move permissions to the core instead of it being a regular database object
//@TODO all methods/pages should check to see if the there is a permission set, and if not, then ignore that permission
//@TODO guest permissions
//@TODO Groups and Group permissions
//@TODO negative permission levels


class Config{
	static $confArray;

	public static function read($name){
		return self::$confArray[$name];
	}

	public static function write($name, $value){
		self::$confArray[$name] = $value;
	}
}

abstract class DatabaseObject{

    public $loaded = false;
    public $id;

    //Force Extending class to define this method
    //abstract protected function classDataSetup();

    public function __construct($id = null){

        if(is_array($id)){

            if($this->toObject($id) === false)
                throw new Exception("Object failed to set new variables");
            else
                $this->loaded = true;

        }else if(Core::isJson($id)){

            if($this->toObject(json_decode($id)) === false)
                throw new Exception("Object Wasn't JSON or failed to set new variables");
            else
                $this->loaded = true;

        }else if($id !== null)
            $this->load($id);


    }

    // Common methods

    /**
     * Saves a Database Object
     *
     * @return Boolean true/false based on success of DB insert
     * @throws PDO error if database is unreachable
     */
    public function save(){
        //a list of keys to be iterated though, generated by Object Attribute Names
        $keyChain = $this->getKeyChain();

        //beginning of building the prepared MYSQL insert statement
        $prepareStatement = "INSERT INTO ".get_class($this)." (";

        foreach($keyChain as $val){
            if($val != "id")//since this is a new object, we don't want to save the ID, rather letting the DB generate an ID
                $prepareStatement .= "$val, ";

        }

        $prepareStatement = rtrim($prepareStatement, ", ");
        $prepareStatement .= ") VALUES (";

        foreach($keyChain as $val){
            if($val != "id")
                $prepareStatement .= ":$val, ";

        }

        $prepareStatement = rtrim($prepareStatement, ", ");
        $prepareStatement .= ")";

        //at this point, the array should be good to go
        //INSERT INTO fruit (color, count) VALUES (:color, :count)
        //we are going to generate the array of variables to be processed by PDO
        //in example, color and count will be overwritten by PDO safely
        //to learn more, refer to PDO manual for more information on specific PDO procedures

        $executeArray = array();

        //our data is gotten from the iterateVisible class
        $dataArray = $this->toArray();

        foreach ($keyChain as $val) {
            if($val != "id")
                $executeArray[':'.$val] = $dataArray[$val];

        }

        try {

            //getting PDO connection and preparing the statement
            $pdo = Core::getInstance();
            $query = $pdo->dbh->prepare($prepareStatement);
            //running the statement with object variables
            $query->execute($executeArray);

            if($query->rowCount() > 0){ //checks to see if there was an object that was inserted into the database
                $this->id = $pdo->dbh->lastInsertId();
                return true;
            }

            return false;

        }catch(PDOException $pe) {
            trigger_error('Could not connect to MySQL database. ' . $pe->getMessage() , E_USER_ERROR);
        }

        return false;
    }

    /**
     * Updates an Database Object
     *
     * @deprecated
     */
    public function saveNew(){
        return $this->save();
    }

    /**
     * Updates an Database Object
     * @param String $identifier, if an ID isn't being used to update an object, the WHERE clause would go here
     * @return Boolean true/false based on success of DB insert
     * @throws PDO error if database is unreachable
     * @todo might want to allow update on a param object
     */
    public function update($identifier = null){
        $keyChain = $this->getKeyChain();

        $prepareStatement = "UPDATE ".get_class($this)." SET ";

        foreach($keyChain as $val){
            if($val != "id")
                $prepareStatement .= "$val = :$val, ";

        }

        $prepareStatement = rtrim($prepareStatement, ", ");

        if($identifier != null){

            foreach($keyChain as $value){

                if(stristr($identifier, $value) !== false)
                    $prepareStatement .= " WHERE {$value} = :{$value}";


            }
        }else{
            $prepareStatement .= " WHERE id = :id";
        }

        $executeArray = array();

        $dataArray = $this->toArray();

        foreach ($keyChain as $val) {

            if (strpos($val,'date') !== false)
                $executeArray[':'.$val] =  Core::unixToMySQL($dataArray[$val]);
            else
                $executeArray[':'.$val] = $dataArray[$val];

        }



        //string should look like this:
        //UPDATE fruit SET color = :color, count = :count WHERE id = :id

        try {

            $pdo = Core::getInstance();
            $query = $pdo->dbh->prepare($prepareStatement);

            $query->execute($executeArray);

            if($query->rowCount() > 0)
                return true;

            return false;

        }catch(PDOException $pe) {

            trigger_error('Could not connect to MySQL database. ' . $pe->getMessage() , E_USER_ERROR);

        }

        return false;

    }

    /**
     * Updates an Database Object
     *
     * @deprecated
     */
    public function saveOld(){
        return $this->update();
    }

    public function erase(){

        $prepareStatement = "DELETE FROM ".get_class($this)." WHERE id = :id";
        $executeArray = array(':id' => $this->id);

        try {

            $pdo = Core::getInstance();
            $query = $pdo->dbh->prepare($prepareStatement);

            $query->execute($executeArray);

            if($query->rowCount() > 0)
                return true;


            return false;

        }catch(PDOException $pe) {

            trigger_error('Could not connect to MySQL database. ' . $pe->getMessage() , E_USER_ERROR);

        }

        return false;

    }


    //data is the thing to be checked, (1, pizza)
    //type is the name of the thing in the DB, (id, food_name)
    //limit is the number of returned results
    //return_object is if the object should be loaded into the current object, or if it should return a new instance.
    //$options = array('salt' => null, 'cost' => 11, 'hashed' => false)
    //$type = null, $limit = 1, $return_object = true
    public function load($data, $options = array('type' => null, 'limit' => 1, 'return_object' => false)){

        if(!is_array($options)){
            $options = array('type' => $options);
        }

        if(!isset($options['type']))
            $options['type'] = null;
        if(!isset($options['cost']))
            $options['limit'] = 1;
        if(!isset($options['return_object']))
            $options['return_object'] = false;


        //a list of keys to be iterated though, generated by Object Attribute Names
        $keyChain = $this->getKeyChain();
        $condition = null;
        $prepareStatement = "SELECT * FROM ".get_class($this)." WHERE ";
        $execArray = null;

        if(is_array($data)){

            $condition = array();
            $execArray = array();

            if(is_array($options['type'])){

                foreach($options['type'] as $value){
                    foreach($keyChain as $val){

                        if(stristr($value, $val) !== false)
                            array_push($condition, $val);


                        if(stristr($value, 'password') !== false)
                            array_push($condition, null);

                    }
                }

            }else if($options['type'] != null){

                for($i = 1; $i < count ($data); $i++){
                    array_push($condition, $options['type']);
                }

            }else{
                for($i = 1; $i < count ($data); $i++){
                    array_push($condition, 'id');
                }
            }

            $count = 0;

            foreach($condition as $value){

                foreach($keyChain as $val){

                    if(stristr($value, 'password') !== false)
                        return false;


                    if($val == 'id'){

                        if($value == $val){
                            $prepareStatement .= "{$val} = :var$count OR ";
                            $execArray[":var$count"] = "$data[$count]";
                            $count++;
                        }

                    }else if(stristr($value, $val) !== false){
                        $prepareStatement .= "{$val} = :var$count OR ";
                        $execArray[":var$count"] = "$data[$count]";
                        $count++;
                    }

                }

            }

            $prepareStatement = rtrim($prepareStatement, " OR ");

            $prepareStatement .= " LIMIT {$options['limit']}";

        }else{ //if data is not an array
            if($options['type'] !== null){
                foreach($keyChain as $val){

                    if(stristr($options['type'], $val) !== false){
                        $condition = $val;
                        break;
                    }

                    if(stristr($options['type'], 'password') !== false){
                        $condition = null;
                        break;
                    }

                }

            }else{
                $condition = 'id';
            }

            $prepareStatement .= " {$condition} = :var";

            $execArray = array(':var' => $data);
        }


        if($condition === null || $execArray === null)
            return false;


        try {

            $pdo = Core::getInstance();
            $query = $pdo->dbh->prepare($prepareStatement);

            $query->execute($execArray);

            if($query->rowCount() == 0)
                return false;


            if($options['return_object']){

                $newInstance = $query->fetchObject(get_class($this));

                if(!is_object($newInstance) && !is_array($newInstance))
                    return false;


                $newInstance->loaded = true;

                return $newInstance;

            }else if($options['return_object'] === false){

                $query->setFetchMode(PDO::FETCH_INTO, $this);
                $query->execute();
                $query->fetch();
                $query->closeCursor();

                $this->loaded = true;

                return true;

            }


        }catch(PDOException $pe) {

            trigger_error('Could not connect to MySQL database. ' . $pe->getMessage() , E_USER_ERROR);

        }

        return false;
    }

    /**
     * Loads an object with a given ID
     * Since its deprecated, this is only going to handle a single ID var.
     *
     * @deprecated
     */
    public function loadInstance($id){
        return $this->load($id);
    }

    /**
     * Loads an object with a given ID
     * returns the object loaded, instead of setting ($this) to the loaded object
     */
    public function returnInstance($data, $options = array('return_object' => true)){

        $options['return_object'] = true;

        return $this->load($data, $options);

    }

    public function getNext($last_id){

        try {

            $pdo = Core::getInstance();
            $query = $pdo->dbh->prepare("SELECT * FROM ".get_class($this)." WHERE id = (SELECT MIN(id) FROM ".get_class($this)." WHERE id > :last_id)");
            $query->execute(array(':last_id' => $last_id));
            $newInstance = $query->fetchObject(get_class($this));

            if(!is_object($newInstance))
                return false;


            return $newInstance;

        }catch(PDOException $pe) {

            trigger_error('Could not connect to MySQL database. ' . $pe->getMessage() , E_USER_ERROR);

        }

        return false;
    }

    /**
     * Loads an object with a given ID
     *
     * @deprecated
     */
    public function getNextInstance($last_id){
        return $this->getNext($last_id);
    }


    public function getList($sorting = null, $condition = null){

        $prepareStatement = "SELECT * FROM ".get_class($this);
        $conditionValue = null;

        if($condition != null){
            $keyChain = $this->getKeyChain();

            foreach($keyChain as $value){

                if(stristr($condition, $value) !== false){

                    $prepareStatement .= " WHERE {$value} = :{$value}";
                    $conditionValue = $value;

                }
            }
        }

        if($sorting != null){

            $keyChain = $this->getKeyChain();

            foreach($keyChain as $value){

                if(stristr($sorting, $value) !== false){

                    if(stristr($sorting, 'asc') !== false)
                        $prepareStatement .= " ORDER BY {$value} ASC";
                    else if(stristr($sorting, 'desc') !== false)
                        $prepareStatement .= " ORDER BY {$value} DESC";
                    else
                        $prepareStatement .= " ORDER BY {$value} DESC";


                }
            }
        }

        try {

            $pdo = Core::getInstance();
            $query = $pdo->dbh->prepare($prepareStatement);

            if($condition != null)
                $query->execute(array(":{$conditionValue}" => explode(" = ", $condition)));
            else
                $query->execute();


            $objects = $query->fetchAll(PDO::FETCH_CLASS, get_class($this));

            if($objects === false)
                return false;


            return $objects;

        }catch(PDOException $pe) {

            trigger_error('Could not connect to MySQL database. ' . $pe->getMessage() , E_USER_ERROR);

        }

        return false;
    }

    public function getKeyChain(){

        $array = array();
        $count = 0;

        foreach($this as $key => $value) {

            if($key !== "loaded")
                $array[$count++] = $key;

        }

        unset($count);

        return $array;

    }

    public function toArray(){

        $array = array();

        foreach($this as $key => $value) {

            if($key !== "loaded")
                $array[$key] = $value;

        }

        return $array;
    }

    public function toObject($array){

        $keyChain = $this->toArray();

        if(is_object($array))
            $array = (array) $array;

        foreach($array as $key => $value){

            if(!array_key_exists($key, $keyChain))
                unset($array[$key]);
            else if($key !== "loaded")
                $this->{$key} = $value;

            if(strpos($key,'date') !== false)
                $this->{$key} = Core::unixToMySQL($value);

        }

        foreach($this as $key => $value) {

            if(isset($array[$key])){
                if(strpos($key,'date') !== false && !Core::isValidDateTimeString($this->{$key}))
                    return false;
                else if($this->{$key} !== $array[$key] && $key !== "loaded" && strpos($key,'date') === false)
                    return false;
            }

        }

        return true;

    }

    //grabs a json string and converts it to the object

    //Magic Methods
    //serialize
    public function __sleep(){

        return $this->toArray();

    }

    public function __toString(){

        return json_encode($this->toArray());

    }

    public function __invoke($dataArray){

        $object = get_class($this);

        return new $object($dataArray);

    }



}


class Core{

	public $dbh;
	private static $instance;

	public function __construct(){

		$dsn = 'mysql:host=' . Config::read('db.host') .
			';dbname='    . Config::read('db.base') .
			';connect_timeout=15';

		$this->dbh = new PDO($dsn, Config::read('db.user'), Config::read('db.password'), array(PDO::ATTR_PERSISTENT => true));
		$this->dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
		$this->dbh->setAttribute(PDO::ATTR_EMULATE_PREPARES, true);
	}

	public static function getInstance(){
		if (!isset(self::$instance)){
			$object = __CLASS__;
			self::$instance = new $object;
		}

		return self::$instance;
	}

    public static function clean($data){
        return htmlspecialchars(mysql_real_escape_string($data));
    }

    public static function isValidDateTimeString($str_dt, $str_dateFormat = null, $str_timezone = null) {

        if(!is_string($str_dt))
            return false;

        if($str_timezone === null)
            $str_timezone = new DateTimeZone('America/New_York');
        else if(is_string($str_timezone))
            $str_timezone = new DateTimeZone($str_timezone);

        if($str_dateFormat === null)
            $str_dateFormat = 'Y-m-d H:i:s';

        $date = DateTime::createFromFormat($str_dateFormat, $str_dt, $str_timezone);

        return $date && DateTime::getLastErrors()["warning_count"] == 0 && DateTime::getLastErrors()["error_count"] == 0;

    }

    public static function unixToMySQL($timestamp){

        if(strtotime($timestamp) === false)
            return date('Y-m-d H:i:s', $timestamp);

        return date('Y-m-d H:i:s', strtotime($timestamp));

    }

    public static function isJson($string)
    {
        // make sure provided input is of type string
        if (!is_string($string))
            return false;

        // trim white spaces
        $string = trim($string);

        // get first character/last character
        $firstChar = substr($string, 0, 1);
        $lastChar = substr($string, -1);

        // check if there is a first and last character
        if (!$firstChar || !$lastChar)
            return false;

        // make sure first character is either { or [
        if ($firstChar !== '{' && $firstChar !== '[')
            return false;


        // make sure last character is either } or ]
        if ($lastChar !== '}' && $lastChar !== ']')
            return false;

        // let's leave the rest to PHP.
        // try to decode string
        json_decode($string);

        return (json_last_error() === JSON_ERROR_NONE);
    }


}

?>